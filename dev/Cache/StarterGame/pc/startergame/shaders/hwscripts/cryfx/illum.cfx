/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
// Original file Copyright Crytek GMBH or its affiliates, used under license.

#include "IllumValidations.cfi"
#include "Common.cfi"

// Shader global descriptions
float Script: STANDARDSGLOBAL
<
string Script =
    "Public;"
#if %DECAL
        "Decal;"
#endif
#if %DEPTH_FIXUP
        "DepthFixup;"
#endif
#if %VERTCOLORS
        "VertexColors"
#endif
#if ENABLE_TESSELLATION
        "HWTessellation;"
#endif
    "SupportsDeferredShading;"
    "SupportsFullDeferredShading;"
    "SupportsAttrInstancing;"
    "ShaderDrawType = Light;"
    "ShaderType = General;"
    >;

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Custom shading pass structure /////////////////////////////////////
struct fragPassCustom
{
};

struct fragLightPassCustom
{
};

#if %BLENDLAYER
    sampler2D DiffuseMap2Sampler
    {
        string UIName = "Second Diffuse Map";
        string UIDescription = "Diffuse Map for the second blend layer";
        Texture = $CustomMap;
        sRGBLookup = true;
    };

    sampler2D SpecularMap2Sampler
    {
        string UIName = "Second Specular Map";
        string UIDescription = "Specular Map for the second blend layer";
        Texture = $Specular2;
        sRGBLookup = false;
    };

    sampler2D BumpMap2Sampler
    {
        string UIName = "Second Normal Map";
        string UIDescription = "Normal Map for the second blend layer";
        Texture = $CustomSecondaryMap;
        sRGBLookup = false;
    };

    sampler2D HeightMap2Sampler
    {
        string UIName = "Second Height Map";
        string UIDescription = "Height Map for the second blend layer";
        Texture = $Subsurface;
        sRGBLookup = false;
    };

    sampler2D BlendMapSampler
    {
        string UIName = "Blend Map";
        string UIDescription = "Blend Map between the two layers";
        Texture = $Opacity;
        sRGBLookup = false;
    };

    sampler2D smoothnessMap2Sampler
    {
        Texture = $SecondSmoothness;
        sRGBLookup = false;
    };
#endif

#if %DECAL
    sampler2D DecalOpacityMapSampler
    {
        string UIName = "Decal Opacity Map";
        string UIDescription = "Opacity map for decal";
        Texture = $Opacity;
        sRGBLookup = false;
    };
#endif

sampler2D emittanceMapSampler
{
    string UIName = "Emittance";
    string UIDescription = "Emittance color/intensity map";
    Texture = $Emittance;
};

#if %OCCLUSION_MAP
    sampler2D OcclusionMapSampler
    {
        string UIName = "Occlusion";
        string UIDescription = "Occlusion map";
        Texture = $Occlusion;
        sRGBLookup = false;
    };
#endif

#include "ShadeLib.cfi"

// Tweakables /////////////////
#if %SAA_FILTERING
half RoughnessBoost
<
    psregister = PS_REG_PM_12.x;
    string UIHelp = "Multiplier for specular antialiasing roughness";
    string UIName = "SAA Roughness Boost";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 10;
    float UIStep = 0.005;
> = 2.0;
	
half RoughnessMaxFootprint
<
    psregister = PS_REG_PM_12.y;
    string UIHelp = "SAA Max Footprint";
    string UIName = "Roughness maximum footprint";
    string UIWidget = "slider";
    float UIMin = 0.0001;
    float UIMax = 10.0;
    float UIStep = 0.005;
> = 0.3;
	
#endif

half EmittanceMapGamma
<
psregister = PS_REG_PM_3.x;
string UIWidget = "slider";
string UIName = "Emittance Map Gamma";
string UIDescription = "Expand range of emittance texture";
float UIMin = 1.0;
float UIMax = 2.0;
float UIStep = 0.1;
> = 1.0;

#if %OFFSET_BUMP_MAPPING
    half ObmDisplacement
    <
    psregister = PS_REG_PM_3.w;
    string UIWidget = "slider";
    string UIName = "OBM Displacement";
    float UIMin = 0.0;
    float UIMax = 0.025;
    float UIStep = 0.001;
    > = 0.004;
#endif

#if %FX_DISSOLVE
    sampler2D DissolveNoiseMapSampler
    {
        string UIName = "Dissolve Noise Map";
        string UIDescription = "Noise map for Dissolve";
        Texture = $Opacity;
        sRGBLookup = false;
    };

    half DissolvePercentage
    <
    psregister = PS_REG_PM_3.y;
    string UIWidget = "slider";
    string UIName = "Dissolve Percentage";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.001;
    > = 0.0;

    half DissolveEdgeThickness
    <
    psregister = PS_REG_PM_3.z;
    string UIWidget = "slider";
    string UIName = "Dissolve Edge Thickness";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    > = 0.0;
	 
    // Dissolve color 
    float4 DissolveColor
    <
    psregister = PS_REG_PM_6;
    string UIHelp = "Set Dissolve color";
    string UIName = "Dissolve Color";
    string UIWidget = "color";
    > = {1.0, 1.0, 1.0, 1.0};
#endif

#if %PARALLAX_OCCLUSION_MAPPING
    half PomDisplacement
    <
    psregister = PS_REG_PM_4.x;
    string UIWidget = "slider";
    string UIName = "POM Displacement";
    float UIMin = 0.0;
    float UIMax = 0.05;
    float UIStep = 0.001;
    > = 0.025;
#endif

#if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
    half SilPomDisplacement
    <
    psregister = PS_REG_PM_10.x;
    vsregister = VS_REG_PM_5.w;
    string UIWidget = "slider";
    string UIName = "Silhouette POM Displacement";
    float UIMin = 0.001;
    float UIMax = 10.0;
    float UIStep = 0.001;
    > = 0.025;

    float SilPomNumSteps
    <
    psregister = PS_REG_PM_10.y;
    string UIWidget = "slider";
    string UIName = "Silhouette POM Number of steps";
    float UIMin = 4.0;
    float UIMax = 512.0;
    float UIStep = 1.0;
    > = 256.0;

    float SilPomStepSizeViewDep
    <
    psregister = PS_REG_PM_10.z;
    string UIWidget = "slider";
    string UIName = "Silhouette POM Step size view independence";
    float UIMin = 1.0;
    float UIMax = 10.0;
    float UIStep = 0.1;
    > = 1.0;
#endif

#if %OFFSET_BUMP_MAPPING || %PARALLAX_OCCLUSION_MAPPING || %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
    half HeightBias
    <
    psregister = PS_REG_PM_4.w;
    vsregister = VS_REG_PM_6.x;
    string UIWidget = "slider";
    string UIName = "Height bias";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.05;
    > = 1.0;

    half SelfShadowStrength
    <
    psregister = PS_REG_PM_4.y;
    string UIWidget = "slider";
    string UIName = "Self shadow strength";
    float UIMin = 0.0;
    float UIMax = 5.0;
    float UIStep = 0.1;
    > = 3.0;
#endif


#if %DETAIL_MAPPING
    half DetailBumpScale
    <
    psregister = PS_REG_PM_5.x;
    string UIHelp = "Set detail bump scale";
    string UIName = "Detail bump scale";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 10.0;
    float UIStep = 0.1;
    > = 0.5;

    half DetailDiffuseScale
    <
    psregister = PS_REG_PM_5.y;
    string UIHelp = "Set diffuse detail blend scale";
    string UIName = "Detail diffuse scale";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    > = 0.5;

    half DetailGlossScale
    <
    psregister = PS_REG_PM_5.z;
    string UIHelp = "Set gloss detail blend scale";
    string UIName = "Detail gloss scale";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 1.0;
    float UIStep = 0.1;
    > = 0.5;
#endif

#if %BLENDLAYER
    half BlendFactor
    <
    psregister = PS_REG_PM_8.x;
    vsregister = VS_REG_PM_5.x;
    dsregister = VS_REG_PM_5.x;
    string UIHelp = "Change visbility of blended layer";
    string UIName = "Blend Factor";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 16.0;
    float UIStep = 0.2;
    > = 8.0;

    half BlendLayer2Tiling
    <
    psregister = PS_REG_PM_8.y;
    vsregister = VS_REG_PM_5.y;
    dsregister = VS_REG_PM_5.y;
    string UIHelp = "Change tiling of 2nd blend layer";
    string UIName = "Blend Layer 2 Tiling";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 20.0;
    float UIStep = 0.005;
    > = 1.0;

    half BlendFalloff
    <
    psregister = PS_REG_PM_8.z;
    vsregister = VS_REG_PM_5.z;
    dsregister = VS_REG_PM_5.z;
    string UIHelp = "Change falloff of blending";
    string UIName = "Blend Falloff";
    string UIWidget = "slider";
    float UIMin = 0.1;
    float UIMax = 128.0;
    float UIStep = 1.0;
    > = 32.0;

    half3 BlendLayer2Diffuse
    <
    psregister = PS_REG_PM_11;	    // w channel is free
    string UIHelp = "Controls Diffuse (Tint) of 2nd blend layer";
    string UIName = "Blend Layer 2 - Diffuse (Tint)";
    string UIWidget = "color";
    > = { 1.0, 1.0, 1.0 };

    half3 BlendLayer2Specular
    <
    psregister = PS_REG_PM_9;	    // w channel is free
    string UIHelp = "Controls Specualr of 2nd blend layer";
    string UIName = "Blend Layer 2 - Specular";
    string UIWidget = "color";
    > = { 0.2314, 0.2314, 0.2314 };

    half BlendLayer2Smoothness
    <
    psregister = PS_REG_PM_8.w;
    string UIHelp = "Controls Smoothness of 2nd blend layer";
    string UIName = "Blend Layer 2 - Smoothness";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 255.0;
    float UIStep = 0.5;
    > = 10.0;

    half BlendMaskTiling
    <
    psregister = PS_REG_PM_7.w;
    vsregister = VS_REG_PM_4.y;
    dsregister = VS_REG_PM_4.y;
    string UIHelp = "Change tiling of blend mask";
    string UIName = "Blend Mask Tiling";
    string UIWidget = "slider";
    float UIMin = 0.05;
    float UIMax = 20.0;
    float UIStep = 0.05;
    > = 1.0;
#endif


#if !%DECAL  // Reusing register
    half SSSIndex
    <
    psregister = PS_REG_PM_7.x;
    string UIHelp = "Change subsurface scattering profile and amount (0.0-0.99: marble, 1.0-1.99: skin)";
    string UIName = "SSS Index";
    string UIWidget = "slider";
    float UIMin = 0.0;
    float UIMax = 3.99;
    float UIStep = 0.005;
    > = 0;
#endif

#if %DECAL
    half DecalFalloff
    <
    psregister = PS_REG_PM_7.y;
    string UIHelp = "Pow applied to decal alpha";
    string UIName = "Decal Alpha Falloff";
    string UIWidget = "slider";
    float UIMin = 0.0001;
    float UIMax = 128.0;
    float UIStep = 1;
    > = 1;

    half DecalAlphaMult
    <
    psregister = PS_REG_PM_7.z;
    string UIHelp = "Multiplier applied to decal alpha";
    string UIName = "Decal Alpha Multiplier";
    string UIWidget = "slider";
    float UIMin = 0;
    float UIMax = 10;
    float UIStep = 0.01;
    > = 1;

    half DecalDiffuseOpacity
    <
    psregister = PS_REG_PM_7.x;
    string UIHelp = "Opacity multiplier for fading out decal diffuse color";
    string UIName = "Decal Diffuse Opacity";
    string UIWidget = "slider";
    float UIMin = 0;
    float UIMax = 1;
    float UIStep = 0.01;
    > = 1;
#endif

    

float4 GlowParams: PB_GlowParams;

////////////////////////////////////////////////////////////////////////////////////////////////////

#if %FX_DISSOLVE
half ClipDissolvedFrags(float2 uv)
{
    // Use the green channel of th noise map. Change this if needed.
    half fDissolveNoise =  GetTexture2D(DissolveNoiseMapSampler, uv).g; 

    half dissolveThreshold = (fDissolveNoise-DissolvePercentage);
    clip(dissolveThreshold);	
    return dissolveThreshold;	  	 
}
#endif

//=========================================================================

#include "VertexLib.cfi"

//=======================================================================
//  Lighting
//=======================================================================

///////////////// light vertex shader //////////////////

#if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
    vert2GeomGeneral IlluminationVS(app2vertGeneral IN)
#else
    vert2FragGeneral IlluminationVS(app2vertGeneral IN)
#endif
{
    vert2FragGeneral OUT = (vert2FragGeneral)0;
    #if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
        vert2GeomGeneral OUT_ext = (vert2GeomGeneral)0;
    #endif

    streamPos vertPassPos = (streamPos)0;
    #if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
        vs_shared_output(IN, OUT, OUT_ext, vertPassPos, true);
    #else
        vs_shared_output(IN, OUT, vertPassPos, true);
    #endif

    #if %DECAL && !%_TT_TEXCOORD_PROJ
        OUT.baseTC.zw = IN.vertCommon.baseTC.xy;
    #endif

    #if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
        OUT_ext.IN = OUT;
        return OUT_ext;
    #else
        return OUT;
    #endif
}

///////////////// geometry shaders //////////////////

#if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
    [maxvertexcount(9)]
    void IlluminationGS(triangle vert2GeomGeneral In[3], inout TriangleStream<geom2FragGeneral> OutStream)
    {
        EmitPrismG(In[0], In[1], In[2], OutStream);
    }
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_unify_parameters(inout fragPass pPass)
{
    pPass.bRenormalizeNormal = true;
    pPass.bDeferredSpecularShading = true;

    #if %OFFSET_BUMP_MAPPING || %PARALLAX_OCCLUSION_MAPPING || %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
        GetMicroDetailParams(pPass.nMicroDetailQuality, pPass.fBumpHeightScale, pPass.fHeightBias, pPass.fSelfShadowStrength);
    #endif

    #if %VERTCOLORS
        pPass.bVertexColors = true;
    #endif

    #if %DETAIL_MAPPING
        pPass.bDetailBumpMapping = true;
        pPass.vDetailBumpTilling = half2(DetailParams.xy);
        pPass.fDetailBumpScale = DetailBumpScale;
        pPass.vDetailBlendAmount = half2(DetailDiffuseScale, DetailGlossScale);

        #if %ALPHAMASK_DETAILMAP
            pPass.bDetailBumpMappingMasking = true;
        #endif
    #endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_begin(inout fragPass pPass)
{
    float4 baseTC = pPass.IN.baseTC;
    float4 bumpTC = pPass.IN.bumpTC;

    // load the diffuse texture
    #if %DECAL && %_RT_DECAL_TEXGEN_2D
        #if %_TT_TEXCOORD_PROJ
            pPass.cDiffuseMap = GetTexture2DProj(diffuseMapSampler_Decal, baseTC.xyzw);
        #else
            pPass.cDiffuseMap = GetTexture2D(diffuseMapSampler_Decal, baseTC.xy);
        #endif
    #endif
    pPass.cDiffuseMap *= MatDifColor;	// Main layer albedo/tint color + alpha

    // Specular component
    pPass.cSpecularMap = MatSpecColor;
    #if %SPECULAR_MAP
        #if !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
            pPass.cSpecularMap *= GetTexture2D(specularMapSampler, baseTC.xy);
        #else
            pPass.cSpecularMap *= GetTexture2DLod(specularMapSampler, float4(baseTC.xy, 0, 0)); // TODO: find way to compute lod without gradients as they cause pixel artifacts at fin / shell transition
        #endif
    #endif

    pPass.fGloss *= GetTexture2D(smoothnessMapSampler, baseTC.xy).r;

    // Output alpha
    half fAlpha = pPass.cDiffuseMap.a;
    if (pPass.bVertexColors)
    {
        fAlpha *= pPass.IN.Color.a;
    }

    #if %DECAL
        #if !%_TT_TEXCOORD_PROJ
            fAlpha *= GetTexture2D(DecalOpacityMapSampler, baseTC.zw).r;
        #else
            fAlpha *= GetTexture2D(DecalOpacityMapSampler, baseTC.xy).r;
        #endif
        fAlpha = saturate(pow(fAlpha * DecalAlphaMult, DecalFalloff));
    #endif

    #if %_RT_DECAL_TEXGEN_2D
        fAlpha *= 100.0 / 99.0; //saturate(1 - dot(pPass.IN.DistAtten, pPass.IN.DistAtten));
    #endif

    pPass.fAlpha = fAlpha * pPass.IN.Ambient.w;

    //-----------------------------------------------
    // Second Blend Layer
    //-----------------------------------------------
#if %BLENDLAYER
        float4 tiledBlendLayerTC = float4(pPass.IN.blendMapTCblendLayerTC.zw * BlendLayer2Tiling, 0, 0);

        #if !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
            half4 diffuseMap2 = GetTexture2D(DiffuseMap2Sampler, tiledBlendLayerTC.xy);
            half4 specularMap2 = GetTexture2D(SpecularMap2Sampler, tiledBlendLayerTC.xy );
            half glossLayer2 = GetTexture2D(smoothnessMap2Sampler, tiledBlendLayerTC.xy ).r;
        #else
            half4 diffuseMap2 = GetTexture2DLod(DiffuseMap2Sampler, tiledBlendLayerTC);	// TODO: find way to compute lod without gradients as they cause pixel artifacts at fin / shell transition
            half4 specularMap2 = GetTexture2DLod(SpecularMap2Sampler, tiledBlendLayerTC );	
            half glossLayer2 = GetTexture2DLod(smoothnessMap2Sampler, tiledBlendLayerTC ).r; 
        #endif

        // Diffuse blend layer calculation
        diffuseMap2.rgb *= BlendLayer2Diffuse.rgb;     // Second layer albedo/tint color is blended separately
        pPass.cDiffuseMap = lerp( pPass.cDiffuseMap, diffuseMap2, pPass.blendFac);

        // Specular blend layer calculation
        specularMap2.rgb *= BlendLayer2Specular.rgb;    // Second layer specular is blended separately
        pPass.cSpecularMap.rgb = lerp(pPass.cSpecularMap.rgb, specularMap2, pPass.blendFac);

        // Gloss blend layer calculation
        const half      div128 = 1.0h / 128.0h;
        glossLayer2 *= (BlendLayer2Smoothness * div128);    // multiplying with layer 2 smoothness 
        pPass.fGloss = lerp(pPass.fGloss, glossLayer2, pPass.blendFac);

#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_per_light(inout fragPass pPass, inout fragLightPass pLight)
{
    pLight.fNdotL = saturate(pLight.fNdotL);

    half3 cDiffuse = pLight.cDiffuse.xyz * DiffuseBRDF(pPass.vNormal.xyz, pPass.vView, pLight.vLight, pPass.fGloss, pLight.fNdotL);
    half3 cSpecular = pLight.cSpecular.xyz * SpecularBRDF(pPass.vNormal, pPass.vView, pLight.vLight, pPass.fGloss, pPass.cSpecularMap.rgb) * pLight.fNdotL;

    half3 cK = pLight.fOcclShadow * pLight.fFallOff * pLight.cFilter;

    pPass.cDiffuseAcc.xyz += cDiffuse.xyz * cK.xyz;
    pPass.cSpecularAcc.xyz += cSpecular.xyz * cK.xyz;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

// remove cAmbient, store in cAmbientAcc
void frag_custom_ambient(inout fragPass pPass, inout half3 cAmbient)
{
    pPass.cAmbientAcc.xyz += cAmbient.xyz;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void frag_custom_end(inout fragPass pPass, inout half3 cFinal)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

#include "fragLib.cfi"

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


sampler2D emissiveIntensitySampler
{
    string UIName = "Emittance Multiplier";
    string UIDescription = "Emittance RGB multiplier map";
    Texture = $DecalOverlay;
};

half3 GetEmittance(fragPass pPass)
{
#if %EMITTANCE_MAP
    half4 emittanceMap = GetTexture2D(emittanceMapSampler, pPass.IN.emittanceTC);
    half4 emissiveIntensityMap = GetTexture2D(emissiveIntensitySampler, pPass.IN.emissiveIntensityTC);
#else
    half4 emittanceMap = half4(1.0, 1.0, 1.0, 1.0);
    half4 emissiveIntensityMap = half4(.5, .5, .5, .5);
#endif

    // Increase the range of non-HDR textures:
    //   AdjustLuminance(emittanceMap.rgb, pow(GetLuminance(emittanceMap.rgb), Gamma));
    emittanceMap.rgb *= pow(max(GetLuminance(emittanceMap.rgb), 1e-6), EmittanceMapGamma - 1);
    emittanceMap.rgb *= emissiveIntensityMap.rgb;

    // DEPRECATED: Just for backwards compatibility (up to 3.8.3)
    emittanceMap.rgb *= emittanceMap.a;

    return GlowParams.xyz * emittanceMap.rgb;
}

//////////////////////////////////////////////////////////////////////

#if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
    EARLYDEPTHSTENCIL
    pixout IlluminationPS(geom2FragGeneral IN_ext)
#else
    EARLYDEPTHSTENCIL
    pixout IlluminationPS(vert2FragGeneral IN)
#endif
{
    #if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
        vert2FragGeneral IN = IN_ext.IN;
    #endif

    pixout OUT = (pixout)0;
    fragPass pPass = (fragPass) 0;

    frag_unify(pPass, IN);

    half3 emittance = half3(0, 0, 0);
    const bool bEmissive = GetLuminance(GlowParams.xyz) > 0;
    if (bEmissive)
    {
        emittance = GetEmittance(pPass);
    }

    #if %_RT_HDR_MODE // Deferred shading used
        if (bEmissive && pPass.IN.Ambient.w == 1)
        {
            // Additive glow pass
            OUT.Color.rgb = emittance;
            return OUT;
        }
    #endif

    half4 cFinal = frag_shared_output(pPass);

    cFinal.rgb += emittance;

    HDROutput(OUT, cFinal, 1);

    DepthFixupOutput(OUT.Color, cFinal.a, IN.WPos);

    return OUT;
}

#include "IllumTess.cfi"

//////////////////////////////// technique ////////////////

technique General
<
string Script =
    "TechniqueZ=ZPass;"
#if !%DECAL && !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING && !ENABLE_TESSELLATION
        "TechniqueZPrepass=ZPrepass;"
#endif
    "TechniqueMotionBlur=MotionBlurPass;"
    "TechniqueCustomRender=CustomRenderPass;"
    "TechniqueShadowGen=ShadowGen;"
    "TechniqueDebug=DebugPass;"
    >
{
    pass p0
    {
        VertexShader = IlluminationVS() GeneralVS;
        #if ENABLE_TESSELLATION
            HullShader   = IllumHS() GeneralHS;
            DomainShader = IllumDS() GeneralDS;
        #endif
        #if %SILHOUETTE_PARALLAX_OCCLUSION_MAPPING
            GeometryShader = IlluminationGS() GeneralGS;
        #endif
        PixelShader = IlluminationPS() GeneralPS;

        #if %DECAL
            ZEnable = true;
            ZWriteEnable = false;
            ZFunc = LEqual;

            CullMode = Back;
        #else
            ZEnable = true;
            ZWriteEnable = true;
            CullMode = Back;
        #endif
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

#if !%DECAL && !%SILHOUETTE_PARALLAX_OCCLUSION_MAPPING && !ENABLE_TESSELLATION
    #include "CommonZPrePass.cfi"
#endif

#include "CommonZPass.cfi"
#include "CommonMotionBlurPass.cfi"
#include "CommonViewsPass.cfi"
#include "ShadowCommon.cfi"
#include "CommonShadowGenPass.cfi"
#include "CommonDebugPass.cfi"
#if PCDX11 || GL4 || GLES3 || METAL || OSXGL4
    #include "MeshBaker.cfi"
#endif

/////////////////////// eof ///
