/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
// Original file Copyright Crytek GMBH or its affiliates, used under license.

#define VS_NO_SKINNING_DATA

// dx11 obfuscated this quite further, clean up for refactor phase

#include "Common.cfi"
#include "ModificatorVT.cfi"
#include "ShadeLib.cfi"
#include "PostEffectsLib.cfi"

float Script : STANDARDSGLOBAL
<
  string Script =
           "Public;"
           "NoPreview;"           
           "ShaderDrawType = General;"                      
           "ShaderType = Water;"
           "PreprType = ScanWater;"

#if %WATER_TESSELLATION_DX11
			"HWTessellation;"
#endif

>;

/// Un-Tweakables //////////////////////

float4x4 mViewProjI : PB_UnProjMatrix; 

float4 VS_SunColor : PB_SunColor;

// getting a warning here
float4x4 mReflProj : PI_TexMatrix
<
  string 'Sampler' (ReflectionSampler)
>;

// water waves parameters    
float4 OceanParams0 = { PB_FromRE[0], PB_FromRE[1], PB_FromRE[2], PB_FromRE[3] };
float4 OceanParams1 = { PB_FromRE[4], PB_FromRE[5], PB_FromRE[6], PB_FromRE[7] };

float3 CameraFrontVector	: PB_CameraFront;
float4 CameraRightVector	: PB_CameraRight;
float4 CameraUpVector			: PB_CameraUp;

// Fog parameters
// For ocean comes from render element
float4 cFogColorDensity = { PB_FromRE[8], PB_FromRE[9], PB_FromRE[10], PB_FromRE[11] };

// Tweakables /////////////////

float SoftIntersectionFactor
<
  psregister = PS_REG_PM_8.x;
  string UIName = "Soft intersection factor";      
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 10.0;
  float UIStep = 0.1;  
> = 1.0;

#if %FAKE_CAMERA_MOVEMENT
	float FakeCameraSpeed
	<
	  vsregister = VS_REG_PM_4.w;
	  string UIName = "Fake camera speed";  
	  string UIWidget = "slider";
	  float UIMin = -10.0;
	  float UIMax = 10.0;
	  float UIStep = 0.001;
	> = 0.0;  
#endif

float Tilling
<
  vsregister = VS_REG_PM_4.x;
  psregister = PS_REG_PM_8.w;
  string UIHelp = "Set bump tilling";                     
  string UIName = "Tilling";  
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 32.0;
  float UIStep = 0.001;
> = 10.0;  

float DetailTilling
<
  vsregister = VS_REG_PM_4.y;
  string UIHelp = "Set detail bump tilling";                     
  string UIName = "Detail Tilling";  
  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 32.0;
  float UIStep = 0.001;;
> = 2.5;  

float RainTilling
<
  psregister = PS_REG_PM_8.y;
  string UIName = "Rain ripples tilling";  
  string UIWidget = "slider";
  float UIMin = 0.0;
	float UIMax = 1.0;
  float UIStep = 0.001;
> = 1.0;  

half FresnelGloss
<
  psregister = PS_REG_PM_5.x;
  string UIName = "Fresnel gloss";  
  string UIWidget = "slider";
  float UIMin = 0;
  float UIMax = 1.0;
  float UIStep = 0.001;
> = 0.9;

half ReflectionScale
<
  psregister = PS_REG_PM_5.z;
  string UIWidget = "slider";
  string UIName = "Reflection scale";
  float UIMin = 0.0;
  float UIMax = 32.0;
  float UIStep = 0.001;
> = 1.0;

half SubSurfaceScatteringScale
<
  psregister = PS_REG_PM_5.w;
  string UIName = "SSS scale";      
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 10.0;
  float UIStep = 0.1;  
> = 2.0;

half ReflectionBumpScale
<
  psregister = PS_REG_PM_4.z;
  string UIWidget = "slider";
  string UIName = "Reflection bump scale";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.001;
> = 0.1;

half RefractionBumpScale
<
  psregister = PS_REG_PM_4.w;
  string UIWidget = "slider";
  string UIName = "Refraction bump scale";
  float UIMin = 0.0;
  float UIMax = 1.0;
  float UIStep = 0.001;
> = 0.1;

half DetailNormalsScale
<
  psregister = PS_REG_PM_6.x;
  string UIWidget = "slider";
  string UIName = "Detail Normals scale";
  float UIMin = 0.0;
  float UIMax = 4.0;
  float UIStep = 0.001;
> = 0.5;

half NormalsScale
<
  psregister = PS_REG_PM_6.y;
  string UIWidget = "slider";
  string UIName = "Normals scale";
  float UIMin = 0.0;
  float UIMax = 4.0;
  float UIStep = 0.001;
> = 1.25;

half GradientScale
<
  psregister = PS_REG_PM_6.z;
  string UIWidget = "slider";
  string UIName = "Gradient scale";
  float UIMin = 0.0;
  float UIMax = 0.15;
  float UIStep = 0.001;
> = 0.1;

half HeightScale
<
  psregister = PS_REG_PM_6.w;
  string UIWidget = "slider";
  string UIName = "Height scale";
  float UIMin = 0.0;
  float UIMax = 0.25;
  float UIStep = 0.001;
> = 0.2;

#if %FOAM

half FoamSoftIntersectionFactor
<
  psregister = PS_REG_PM_3.x;
  string UIName = "Foam soft intersection";      
  string UIWidget = "slider";
  float UIMin = 0.35;
  float UIMax = 10.0;
  float UIStep = 0.1;  
> = 0.75;

half FoamAmount
<
  psregister = PS_REG_PM_3.y;
  string UIName = "Foam Amount";  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 8.0;
  float UIStep = 0.001;
> = 1.0;  

half FoamCrestAmount
<
  psregister = PS_REG_PM_3.w;
  string UIName = "Crest Foam Amount";  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 10.0;
  float UIStep = 0.001;
> = 1.0;  

half FoamTilling
<
  psregister = PS_REG_PM_3.z;
  string UIName = "Foam tilling";  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 32.0;
  float UIStep = 0.001;
> = 12.0;  

#endif

half RipplesNormalsScale
<
  vsregister = VS_REG_PM_4.z;
  string UIName = "Ripples normals scale";  
  string UIWidget = "slider";
  float UIMin = 0.0;
  float UIMax = 4.0;
  float UIStep = 0.001;
> = 1.0;  

////////////////////////////////////////////////////////////////

sampler2D FFTVertexTexSampler : register(s0);
sampler2D WaterDynRipplesVertexTexSampler : register(s1);

sampler2D ReflectionSampler : register(s0)
<
  string Script =
      "RenderOrder=PreProcess;"
      "ProcessOrder=WaterReflection;"
      "RenderCamera=WaterPlaneReflected;"
      "RenderTarget_IDPool = _RT2D_WATER_ID;"
      "RenderTarget_Width=$ScreenSize;"
      "RenderTarget_Height=$ScreenSize;"
      "RenderTarget_UpdateType=WaterReflect;"
      "RenderDepthStencilTarget=DepthBuffer;"
      "ClearSetColor=Black;"
      "ClearSetDepth=1;"
      "ClearTarget=Color;"
      "ClearTarget=Depth;";
>
{
  Texture = $RT_2D;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = NONE;
  AddressU = Clamp;
  AddressV = Clamp;   
};

sampler2D RefractionSampler : register(s1)
{
  Texture = $SceneTarget;  
  MinFilter = POINT;
  MagFilter = POINT;
  MipFilter = POINT;
  AddressU = Clamp;
  AddressV = Clamp;   
  sRGBLookup = true; 
};

samplerCUBE envMapSamplerCUBE = sampler_state
{ 
  Texture = $FromObjCM; 
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR;
  AddressU = Clamp;
  AddressV = Clamp;
  AddressW = Clamp;	
};

sampler2D WaterNormalsSampler
{
  // eTF_A8B8G8R8S
  //eTF_R8G8B8A8 for fixed point
  Texture = $WaterVolumeDDN;

  MinFilter = ANISOTROPIC;
  MagFilter = ANISOTROPIC;
  MipFilter = ANISOTROPIC;
	AnisotropyLevel = 16;

  AddressU = Wrap;
  AddressV = Wrap;   
};

#ifdef FIXED_POINT
  //eTF_R8G8B8A8
  float4 ExpandWaterNormals( float4 waterNormals)
  {
    return EXPAND(waterNormals);
  }
#else
  // eTF_A8B8G8R8S
  float4 ExpandWaterNormals( float4 waterNormals)
  {
    return waterNormals;
  }
#endif

sampler2D FoamSampler 
{
  Texture = EngineAssets/Shading/WaterFoam.tif;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR;
  AddressU = Wrap;
  AddressV = Wrap;	

	sRGBLookup = false; 
};

sampler2D WaterGlossMapSampler
{ 
  Texture = EngineAssets/Textures/water_gloss.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  
  // Hack for having noisy/sharp specular highlights. Bad for performance but even with anisotropic filtering it looks too smooth
  MipFilter = LINEAR; 

  AddressU = Wrap;
  AddressV = Wrap;  

	sRGBLookup = false; 
};

sampler2D RainRipplesSampler = sampler_state
{
  // eTF_BC5S
  Texture = Textures/Rain/Ripple/ripple#01_24_ddn.dds;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;
};

sampler2D WaterDynRipplesSampler = sampler_state
{    
  // eTF_A8R8G8B8
  Texture = $WaterRipplesDDN_0;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = LINEAR; 
  AddressU = Clamp;
  AddressV = Clamp;
};

sampler2D WaterDisplMapSampler = sampler_state
{    
  // eTF_A32B32G32R32F
  Texture = $WaterOceanMap;
  MinFilter = LINEAR;
  MagFilter = LINEAR;
  MipFilter = POINT; 
  AddressU = Wrap;
  AddressV = Wrap;
};

/////////////////////////////

struct a2v
{
  float4 Position : POSITION;

  float2 baseTC   : TEXCOORD;
  float4 Color    : COLOR;
};

struct v2f
{
#if !%WATER_TESSELLATION_DX11
	float4 Position		: POSITION; 
#endif

	float4 baseTC	  : TEXCOORDN;
	float4 screenProj : TEXCOORDN; 
	float4 envTC      : TEXCOORDN;
	half4  vView  	  : TEXCOORDN;

	half4 GlossinessK : TEXCOORDN;
	half4 cSpecular   : TEXCOORDN;

	float4 vPosWS		: TEXCOORDN; 

#if %_RT_SAMPLE4
	float4 ripplesTC	: TEXCOORDN;
#endif

	half4 vVertexNormal : TEXCOORDN;
#if %WATER_TESSELLATION_DX11
	float4 vOceanParams : TEXCOORDN;
#endif
};

struct v2f_hs
{
	float4 Position		: POSITION; 
	float4 baseTC	  : TEXCOORDN;
	float4 screenProj : TEXCOORDN; 
	float4 envTC      : TEXCOORDN;
	half4  vView  	  : TEXCOORDN;

	half4 GlossinessK : TEXCOORDN;
	half4 cSpecular   : TEXCOORDN;

	float4 vPosWS		: TEXCOORDN; 

#if %_RT_SAMPLE4
	float4 ripplesTC	: TEXCOORDN;
#endif

	half4 vVertexNormal : TEXCOORDN;
#if %WATER_TESSELLATION_DX11
	float4 vOceanParams : TEXCOORDN;
#endif
};

////////////////////////////////////////////////////////////////////////////////////////////////// 	
// DX11 specifics

struct HS_CONSTANT_DATA_OUTPUT
{
	float	Edges[3]		 : SV_TessFactor;
	float	Inside			 : SV_InsideTessFactor;
};

struct HS_CONTROL_POINT_OUTPUT
{  
	float4 baseTC	  : TEXCOORDN;
	float4 screenProj : TEXCOORDN; 
	float4 envTC      : TEXCOORDN;
	half4  vView  	  : TEXCOORDN;

	half4 GlossinessK : TEXCOORDN;
	half4 cSpecular   : TEXCOORDN;

	float4 vPosWS		: TEXCOORDN; 

#if %_RT_SAMPLE4
	float4 ripplesTC	: TEXCOORDN;
#endif

//if !%_RT_QUALITY && %_RT_QUALITY1
	half4 vVertexNormal : TEXCOORDN;
	float4 vOceanParams : TEXCOORDN;
//endif

};

////////////////////////////////////////////////////////////////////////////////////////////////// 	
// Bilinear filtered texture read

float4 tex2DlodBilinear( in sampler2D s, in float2 t, in float2 textureSize, in float2 texelSize )
{
	float2 f = frac( t * textureSize );

	// TODO: take advantage of arbitrary swizzles for 2.x & 3.0
	float4 t00 = tex2Dlod( s,  float4(t, 0, 0) );
	float4 t10 = tex2Dlod( s, float4( t + float2( texelSize.x, 0 ), 0, 0) );
	float4 tA = lerp( t00, t10, f.x );

	float4 t01 = tex2Dlod( s, float4( t + float2( 0, texelSize.y ), 0, 0) );
	float4 t11 = tex2Dlod( s, float4( t + float2( texelSize.x, texelSize.y ), 0, 0) );
	float4 tB = lerp( t01, t11, f.x );

	return lerp( tA, tB, f.y );
}

////////////////////////////////////////////////////////////////////////////////////////////////// 	
// Get vertex from screen space into world space

void GetGridVertexPos( inout float4 vPos )
{ 
#if %WATER_TESSELLATION_DX11

	// lower than hi spec uses low tesselated screen space grid and no vertex displacement
	float4 vPosOrig = vPos;
	//vPos.xy = (vPos.xy + VS_WaterMeshParams.xy) /VS_WaterMeshParams.w;
	vPos.xy = (vPos.xy*2-1) * ( (vPos.w >0.98)?g_VS_NearFarClipDist.y*2 : 500.0);

	// snap grid to avoid translation aliasing - this can be improved..
	float2 cpos = g_VS_WorldViewPos.xy;

	// ATI specific fix - skip using frac togheter with big values, breaks somehow. Alternatively better compute this on cpu 
	cpos.xy -= frac(cpos.xy / 100.0) * 100.0;

	vPos.xy += cpos;//g_VS_WorldViewPos.xy;

	// set ocean level and add offset to hide precision artifact at horizon
	vPos.z = OceanParams1.w + (4.5f * (vPos.w > 0.98f));

	return;
#endif

	if( GetShaderQuality() >= QUALITY_HIGH )
	{
		// hi specs uses regular tessellated grid plus vertex displacement

		float atten = ( vPos.z );
	  
		// simple lod - keep nearby detail until 200 meters after that project all vertices to horizon
		float fLod0 = 100 *( 1/ min(OceanParams0.w, 2.0 ));

		// Set a 45 degree rotation to the grid
		vPos.xy = 0.707 * vPos.xy + 0.707 * float2( - vPos.y, vPos.x);
	  
		float3x3 mCam = float3x3( CameraRightVector.xyz, CameraUpVector.xyz, CameraFrontVector.xyz);

		// select better projection axis if front angle too steep
		const float fFrontThreshold = 0.75;
		float fFrontDotUpAxis = abs( CameraFrontVector.z );
		if( fFrontDotUpAxis > fFrontThreshold )
		{
			mCam[1] = CameraFrontVector;
			mCam[2] = -CameraUpVector;
		}

		mCam = transpose( mCam );

		// Orientate along camera direction - try keeping good amount of triangles on screen    
		float3 vPosRot = ( mul(( (const float3x3) mCam ), -fLod0 * float3(vPos.x, 0, vPos.y - 0.3)) );	

		// snap grid to avoid translation aliasing - this can be improved..
		float2 cpos = g_VS_WorldViewPos.xy;

		// ATI specific fix - skip using frac together with big values, breaks somehow. Alternatively better compute this on cpu 
		cpos.xy -= (atten <0.98)?frac(cpos.xy / 10.0) * 10.0 : 0;

		float fDistCamera = length(vPosRot.xy);
		fDistCamera *= fDistCamera*0.085;

		//ATI specific fix - stretch the grid according to the direction, mainly the nearer half so that the border cells are always outside the screen
		float t = dot(normalize(CameraFrontVector.xy), normalize(vPosRot.xy));
		fDistCamera *= 1 + (t +1.0) * (t +1.0) * abs(g_VS_WorldViewPos.z - OceanParams1.w) / 16;		//stretch grid according to camera height so that the projected grid
		
		// snap edges in front of camera to horizon - multiply FarDist by 2 to remove unnecessary gaps btwn ocean and sky.
		fDistCamera = (sign(-t) * atten >0.98)?g_VS_NearFarClipDist.y*2 : fDistCamera; 
		
		// ATI specific fix - clamp values to reasonable range
		fDistCamera = min(16384.0f, fDistCamera);

		// add offset to ocean level to hide precision artifact at horizon
		float fLevelOffset = (4.5f * (atten > 0.98f));

		vPos = float4( cpos.xy + normalize(vPosRot.xy)* fDistCamera , OceanParams1.w + fLevelOffset, 1);
	}
	else
	{
		// lower than hi spec uses low tessellated screen space grid and no vertex displacement

		const float fGridQuadSize = 1.0 / (10);
		vPos.xy = (vPos.xy)*2 - 1 ;  
		vPos.xy *= 1.0 + fGridQuadSize*0.5;     
		vPos.zw = float2(0, 1);
		
#if %_RT_REVERSE_DEPTH
		vPos.z = vPos.w - vPos.z;
#endif

		float4 vPosWS = mul( mViewProjI, vPos );
		vPosWS /= vPosWS.w;
	  
		// invert sign when bellow water
		float fDirSign = sign( g_VS_WorldViewPos.z - OceanParams1.w); 

		// get z plane intersections
		float2 z_isecs = fDirSign* float2( g_VS_WorldViewPos.zz - float2( vPosWS.z, OceanParams1.w ) );
		//z_isecs.x = max( z_isecs, 0.05 / g_VS_NearFarClipDist.y);
		z_isecs.x = max( z_isecs, g_VS_NearFarClipDist.w);

		// clamp t just in case
		//float  t = min( z_isecs.y / z_isecs.x, g_VS_NearFarClipDist.y * 5.0 );

		float  t = z_isecs.y / z_isecs.x;
	          
		// project vertex along ray direction
		float2 vRayDir = (vPosWS.xy - g_VS_WorldViewPos.xy);        
		vPos.xy = g_VS_WorldViewPos.xy + vRayDir.xy * t;
	    
		// Output ocean level and try avoid precision artefacts at horizon line by adding an offset
		vPos.z = OceanParams1.w + (t / g_VS_NearFarClipDist.y);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Map water ripples from world to uv space
float4 WaterRipplesLookupParams : PB_WaterRipplesLookupParams;

float4 GetWaterRipplesUvs( inout float4 vPos )
{
	const float fadeStrength = 0.1;
	
	float4 tcWaterRipples = 1;
	tcWaterRipples.xy = vPos.xy * WaterRipplesLookupParams.x + WaterRipplesLookupParams.zw;

	float2 dist = abs(vPos.xy - g_VS_WorldViewPos.xy);
	float2 strength = saturate((WaterRipplesLookupParams.y - dist) * fadeStrength);
	tcWaterRipples.w = min(strength.x, strength.y);

	return tcWaterRipples;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Apply vertex dynamic displacement - additional ocean eye candy for hispecs

void ApplyVertexDisplacement( inout float4 vPos, inout v2f OUT)
{
#if !%_RT_QUALITY && %_RT_QUALITY1
	// Apply FFT vertex displacement

	float2 tcFFT = (vPos.xy)*0.0125*OceanParams0.w * 1.25;
	float4 vtxDispl = tex2Dlod( FFTVertexTexSampler, float4(  tcFFT, 0 ,0) );

	float fCamDist = length(vPos.xyz-g_VS_WorldViewPos.xyz);
	float fDisplaceAtten = saturate( fCamDist * 0.5	 );
	fDisplaceAtten *= fDisplaceAtten;

	vPos.xyz += fDisplaceAtten * vtxDispl.xyz * 0.06 * OceanParams1.x * float3(1.5,1.5,1); 

	// Compute normal on the fly (todo: prebake this in texture alpha..)
	float4 h0 =  vtxDispl;
	float4 h10 = tex2Dlod(FFTVertexTexSampler, float4(tcFFT + float2( 1.0h/64.0, 0), 0, 0));
	float4 h11 = tex2Dlod(FFTVertexTexSampler, float4(tcFFT + float2( 0, 1.0h/64.0), 0, 0));
	half3 vWeights = half3(h0.z, h10.z, h11.z);
	half3 vNormal = half3( (vWeights.x - vWeights.y), (vWeights.x - vWeights.z), 8); 
	vNormal = normalize(vNormal.xyz);                                               
	OUT.vVertexNormal.xyz = vNormal;	
#endif
	
	// Apply dynamic ripples displacement

#if %_RT_SAMPLE4
	OUT.ripplesTC = GetWaterRipplesUvs( vPos );

	#if !%_RT_QUALITY && %_RT_QUALITY1
		vtxDispl = tex2Dlod( WaterDynRipplesVertexTexSampler, float4(  OUT.ripplesTC.xy, 0 ,0) );
		vPos.z -=  ( vtxDispl.z )* OUT.ripplesTC.w; 		//0.5 *
	#endif
#endif	
}

////////////////////////////////////////////////////////////////////////////////////////////////////

v2f WaterVS(a2v IN)
{
	v2f OUT = (v2f)1; 
	float4 vPos = IN.Position;          
	vPos.w = vPos.z; // store edge information

	// Prepare mesh position
	GetGridVertexPos( vPos ); 
	
	float4x4 InstMatrix = GetInstanceMatrix(); 
	vPos.xyz = mul( InstMatrix, float4(vPos.xyz, 1) );
	vPos.xyz += g_VS_WorldViewPos.xyz;

	float4 vPosOrig = vPos; 

#if !%WATER_TESSELLATION_DX11
  	// Apply FFT and dynamic water interaction
	ApplyVertexDisplacement( vPos, OUT );

	OUT.Position = mul(g_VS_ViewProjMatr, float4(vPos.xyz, 1)); 
#endif

	// Output projected reflection texture coordinates
	float4 vProjTex = mul(mReflProj, float4(vPos.xyz, 1) );
	OUT.envTC = vProjTex;

	// Output eye/light vector
	float3 vView = g_VS_WorldViewPos.xyz - vPos.xyz;                                                // 1 alu

  
	OUT.vView.xyz =  ( vView.xyz );                                                       // 3 alu
	OUT.vView.w = sign( OUT.vView.z );
                                                        // 4 alu  
	// Output projected refraction texture coordinates
#if !%WATER_TESSELLATION_DX11
	// Avoid near clipping
	if( dot(OUT.vView.xyz, OUT.vView.xyz) < 2.0*2.0 )
	{
#if %_RT_REVERSE_DEPTH
		OUT.Position.z = ( abs(vView.z) > 0.2 ) ? OUT.Position.z : OUT.Position.w;
#else
		OUT.Position.z *=saturate( abs(vView.z) > 0.2 );
#endif
	}

	OUT.screenProj.xyw = HPosToScreenTC( OUT.Position ).xyw;                                      
#endif

	// Output refraction depth scale
	OUT.screenProj.z = saturate( 1 - 0.15 * sqrt( saturate(OUT.screenProj.w) ) );

#if !%_RT_QUALITY && %_RT_QUALITY1
	float fNormalsAttenuation = saturate( 1 - 0.01 * ( OUT.screenProj.w ) );
	OUT.vVertexNormal.xyz = lerp( float3(0,0,1),OUT.vVertexNormal.xyz,fNormalsAttenuation);
#endif
			
	// Output pre-computed phong normalization (saves 0.4ms on fragment shader)
	OUT.GlossinessK.x = 4.0 * GlossToSpecExp255(MatSpecColor.w);
	OUT.GlossinessK.y = 0.5 * GlossToSpecExp255(MatSpecColor.w);
	OUT.GlossinessK.z = OUT.GlossinessK.x * ONE_OVER_TWO_PI + ONE_OVER_PI;		
	OUT.GlossinessK.w = OUT.GlossinessK.y * ONE_OVER_TWO_PI + ONE_OVER_PI;

	OUT.cSpecular.xyz = MatSpecColor * VS_SunColor.xyz * VS_SunColor.w; // also take sun specular into account

	// Output bump layers texture coordinates
	float2 FlowDir = OceanParams1.yz;  

	float2 vTranslation= ( g_VS_AnimGenParams.z *  OceanParams0.y *  0.0025)* FlowDir; 

	// dont touch this scales
	float2 vTex = vPos.xy * 0.005;                                             // 1 alu

#if %FAKE_CAMERA_MOVEMENT
	vTex = (vPos.xy + FlowDir.xy* (g_VS_AnimGenParams.x*max(-0.35, min(0.35, FakeCameraSpeed*0.5)))) * 0.005;
#endif	

	// Output texture coordinates for water - don't touch texture scales
	OUT.baseTC.xywz = vTex.xyxy * float4(1, 1, 2, 2)*Tilling + vTranslation.xyxy * float4(1, 1, 2, 2);

#if %WATER_TESSELLATION_DX11
	DetailTilling = max(2, DetailTilling);
#endif
	OUT.baseTC.wz *= DetailTilling;
  
////////////////////////////////////////////////////////////////////////////////////////////////// 	

	OUT.vPosWS = vPos;
	OUT.vPosWS.w = IN.Position.z;

////////////////////////////////////////////////////////////////////////////////////////////////// 	

#if %WATER_TESSELLATION_DX11
	OUT.vOceanParams.x = OceanParams1.x;
	OUT.vOceanParams.w = OceanParams0.w;
#endif

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// DX11 specifics

HS_CONSTANT_DATA_OUTPUT WaterConstantsHS(InputPatch<v2f, 3> p, uint PatchID : SV_PrimitiveID )
{
#if (D3DX_SDK_VERSION == 43)
	// Workaround for the optimization rule problem of DXSDKJune10's HLSL Compiler (9.29.952.3111)
	// See: http://support.microsoft.com/kb/2448404	
	#pragma ruledisable 0x0802405f  ;
#endif

	HS_CONSTANT_DATA_OUTPUT OUT = (HS_CONSTANT_DATA_OUTPUT)0;

	// map inputs
	float3 vWP0 = -p[0].vView.xyz+g_VS_WorldViewPos.xyz;
	float3 vWP1 = -p[1].vView.xyz+g_VS_WorldViewPos.xyz;
	float3 vWP2 = -p[2].vView.xyz+g_VS_WorldViewPos.xyz;

	float3 vMiddle = (vWP0 + vWP1 + vWP2) / 3.0f;
	float3 vDir = normalize(g_VS_WorldViewPos.xyz - vMiddle);
	float3 vNormal = normalize(cross(vWP2 - vWP0, vWP1 - vWP0));
	float fDot = dot(vNormal, vDir);
	bool bBackFaceCull = false;//(fDot > 0.01);
	bool bFrustumCulled = ViewFrustumCull(vWP0, vWP1, vWP2, g_VS_FrustumPlaneEquation, 5.0);
  	
	if (bFrustumCulled || bBackFaceCull)
	{
		// Set all tessellation factors to 0 if frustum cull test succeeds
		OUT.Edges[0] = 0.0;
		OUT.Edges[1] = 0.0;
		OUT.Edges[2] = 0.0;
		OUT.Inside   = 0.0;
	}
	else
	{
		// Check edges ws distance - if too big mesh needs to be pre-diced. todo: verify if we can update levels for patches
		float fEdgeDistThreshold = 100;
		bool bNeedsPreDicing = distance(vWP0, vWP1) > fEdgeDistThreshold || distance(vWP1, vWP2) > fEdgeDistThreshold || distance(vWP0, vWP2) > fEdgeDistThreshold;

		{
			float4 vEdgeTessellationFactors;


			// Min and max distance should be chosen according to scene quality requirements
			vMiddle = (p[0].vView.xyz + p[1].vView.xyz + p[2].vView.xyz) / 3.0f;

			float fMaxFactor = 16;

			float TessellationFactorEdge = 32;
			float TessellationFactorInside = 32;

			const float fMinDistance = 0;
			const float fMaxDistance = 300;

			float fTessScale = 1;
			
			float fInside = TessellationFactorInside * fTessScale;
			float fEdge = TessellationFactorEdge * fTessScale;
			// Tessellation level fixed by variable
			vEdgeTessellationFactors = float4(fEdge, fEdge, fEdge, fInside);

			vEdgeTessellationFactors.xyz = distance(vWP2, vWP1);
			vEdgeTessellationFactors.x /= distance((vWP2 + vWP1) / 2, g_VS_WorldViewPos.xyz);
			vEdgeTessellationFactors.y = distance(vWP2, vWP0);
			vEdgeTessellationFactors.y /= distance((vWP2 + vWP0) / 2, g_VS_WorldViewPos.xyz);
			vEdgeTessellationFactors.z = distance(vWP0, vWP1);
			vEdgeTessellationFactors.z /= distance((vWP0 + vWP1) / 2, g_VS_WorldViewPos.xyz);

			float rAvg = max( max(vEdgeTessellationFactors.x, vEdgeTessellationFactors.y),  vEdgeTessellationFactors.z) ;
			vEdgeTessellationFactors.w = saturate(rAvg);
			vEdgeTessellationFactors.xyz *= fEdge;
			vEdgeTessellationFactors.w *= fInside;

			// Assign tessellation levels
			OUT.Edges[0] = clamp(vEdgeTessellationFactors.x, 1, fMaxFactor);
			OUT.Edges[1] = clamp(vEdgeTessellationFactors.y, 1, fMaxFactor);
			OUT.Edges[2] = clamp(vEdgeTessellationFactors.z, 1, fMaxFactor);
			OUT.Inside   = clamp(vEdgeTessellationFactors.w, 1, fMaxFactor);
		}
	}

	return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("tri")]
[partitioning("fractional_odd")]
[outputtopology("triangle_cw")]
[outputcontrolpoints(3)]
[patchconstantfunc("WaterConstantsHS")]
[maxtessfactor(16)]
HS_CONTROL_POINT_OUTPUT WaterHS(InputPatch<v2f, 3> inputPatch, uint uCPID : SV_OutputControlPointID )
{
  HS_CONTROL_POINT_OUTPUT OUT = (HS_CONTROL_POINT_OUTPUT)0;

  // passthrough hull shader
  OUT.baseTC = inputPatch[uCPID].baseTC;
  OUT.screenProj = inputPatch[uCPID].screenProj;
  OUT.envTC = inputPatch[uCPID].envTC;
  OUT.vView = inputPatch[uCPID].vView;
  OUT.GlossinessK = inputPatch[uCPID].GlossinessK;
  OUT.cSpecular = inputPatch[uCPID].cSpecular;
  OUT.vPosWS = inputPatch[uCPID].vPosWS;
  OUT.vOceanParams = inputPatch[uCPID].vOceanParams;
  
#if %_RT_SAMPLE4
  OUT.ripplesTC = inputPatch[uCPID].ripplesTC;
#endif

  return OUT;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

[domain("tri")]
v2f_hs WaterDS(HS_CONSTANT_DATA_OUTPUT IN,float3 BarycentricCoords : SV_DomainLocation, const OutputPatch<HS_CONTROL_POINT_OUTPUT, 3> TriPatch )
{
  v2f_hs OUT = (v2f_hs)0;

  // interpolate attributes

  OUT.baseTC = BarycentricInterp(BarycentricCoords, TriPatch[0].baseTC, TriPatch[1].baseTC, TriPatch[2].baseTC);
  OUT.envTC = BarycentricInterp(BarycentricCoords, TriPatch[0].envTC, TriPatch[1].envTC, TriPatch[2].envTC);
  OUT.vView = BarycentricInterp(BarycentricCoords, TriPatch[0].vView, TriPatch[1].vView, TriPatch[2].vView);
  OUT.GlossinessK = BarycentricInterp(BarycentricCoords, TriPatch[0].GlossinessK, TriPatch[1].GlossinessK, TriPatch[2].GlossinessK);
  OUT.cSpecular = BarycentricInterp(BarycentricCoords, TriPatch[0].cSpecular, TriPatch[1].cSpecular, TriPatch[2].cSpecular);

  OUT.vPosWS = BarycentricInterp(BarycentricCoords, TriPatch[0].vPosWS, TriPatch[1].vPosWS, TriPatch[2].vPosWS);   

  float4 vWorldPos = float4(-OUT.vView.xyz + g_VS_WorldViewPos.xyz, 1);

	float fCamDist = length(vWorldPos.xyz-g_VS_WorldViewPos.xyz);
	float fDisplaceAtten = saturate( fCamDist * 0.5	 );
	fDisplaceAtten *= fDisplaceAtten;

  float4 vtxDispl = 0;
  
  float2 tcFFT = (vWorldPos.xy)*0.0125 * TriPatch[0].vOceanParams.w;
  vtxDispl = GetTexture2DLod( WaterDisplMapSampler, float4( tcFFT, 0 ,0) );
  vtxDispl += GetTexture2DLod( WaterDisplMapSampler, float4(  tcFFT * 2, 0 ,0) )* float4(1.5,1.5,1, 1);
  vtxDispl *= fDisplaceAtten;
  vWorldPos.xyz += vtxDispl* 0.06 * TriPatch[0].vOceanParams.x  ;

  float4 vtxDispl2 = GetTexture2DLod( WaterDisplMapSampler, float4( tcFFT + float2(1.0/64, 0), 0 ,0) );
  vtxDispl2 += GetTexture2DLod( WaterDisplMapSampler, float4(  tcFFT * 2 + float2(1.0/64, 0), 0 ,0) )* float4(1.5,1.5,1, 1);
  vtxDispl2 *= fDisplaceAtten;
	
  float4 edgeLen = (vtxDispl2 - vtxDispl);
  vWorldPos.w =  saturate(  -(edgeLen.x +edgeLen.y)*0.035 );

  //vWorldPos.w = TriPatch[0].vOceanParams.w;//vtxDispl.z;

  float3 vVtxN = ExpandWaterNormals(GetTexture2DLod(WaterNormalsSampler, float4( tcFFT, 0, 0))).xyz;
  vVtxN += ExpandWaterNormals(GetTexture2DLod(WaterNormalsSampler, float4(  tcFFT * 2, 0 , 0))).xyz;

  OUT.vVertexNormal.xyz = lerp( vVtxN, float3(0,0,1), saturate(OUT.vPosWS.w*2) ) ;
  vWorldPos.w =  lerp(vWorldPos.w, 0, saturate(OUT.vPosWS.w*1.5) ) ;
  vtxDispl = 0;

#if %_RT_SAMPLE4
  OUT.ripplesTC = GetWaterRipplesUvs( vWorldPos );		
  float fRipplesDisp = 0.5*GetTexture2DLod( WaterDynRipplesSampler, float4(  OUT.ripplesTC.xy, 0,0.0) ).z;
  vtxDispl -= fRipplesDisp * OUT.ripplesTC.w ;
#endif

  vWorldPos.z += vtxDispl.z;  
  
  OUT.vPosWS = vWorldPos;

  // Transform world position with viewprojection matrix
 float4 HPosition = mul(g_VS_ViewProjMatr, float4(vWorldPos.xyz, 1)); //g_VS_ViewProjMatr //mViewProj
 OUT.Position = HPosition;

// Avoid near clipping
// MK: since we have soft blending with the near plane it's not needed
// MK: was causing completely culled triangles -> C3:DT18198
// if( length(OUT.vView) < 2.0 )
//	 OUT.Position.z *=saturate( abs(OUT.vView.z) > 0.2 );

 OUT.screenProj = HPosToScreenTC(HPosition);
 // Output refraction depth scale
 OUT.screenProj.z = saturate( 1 - 0.15 * sqrt( saturate(OUT.screenProj.w) ) );

  return OUT;
}

[maxvertexcount(3)]
void WaterGS(triangle v2f_hs In[3], inout TriangleStream<v2f_hs> OutStream)
{
  float3 faceEdgeA = In[1].vPosWS - In[0].vPosWS;
  float3 faceEdgeB = In[2].vPosWS - In[0].vPosWS;
  float3 faceEdgeC = In[2].vPosWS - In[1].vPosWS;

  float3 vEdgeLen = float3( length(faceEdgeA), length(faceEdgeB), length(faceEdgeC) );

  v2f_hs Out = (v2f_hs)In[0];
  Out.vPosWS.w = saturate(1- dot(vEdgeLen.xyz, 1)*0.15 );
  OutStream.Append(Out);

  Out = (v2f_hs)In[1];
  Out.vPosWS.w = saturate(1- dot(vEdgeLen.xyz, 1)*0.15 );
  OutStream.Append(Out);

  Out = (v2f_hs)In[2];
  Out.vPosWS.w = saturate(1- dot(vEdgeLen.xyz, 1)*0.15 );
  OutStream.Append(Out);

  OutStream.RestartStrip();
}

////////////////////////////////////////////////////////////////////////////////////////////////////

half3 BumpGen( in v2f_hs IN, float2 vParalaxOffset )
{
	half3 bumpNormal = 0;

	// hi frequency
	bumpNormal.xy = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, IN.baseTC.wz + vParalaxOffset.xy)).xy * DetailNormalsScale;

	// low frequency
	float4 tcBase = IN.baseTC.xyxy * float4(0.25, 0.25, 1, 1) + vParalaxOffset.xyxy;

#if !%_RT_QUALITY && %_RT_QUALITY1 || %WATER_TESSELLATION_DX11
	bumpNormal    += ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.xy)).xyz + ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.zw)).xyz;
	bumpNormal.xy *= NormalsScale*0.5;
#else
	bumpNormal    += ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.xy)).xyz + ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBase.zw)).xyz;
	bumpNormal.xy *= NormalsScale;
#endif
	
#if %_RT_SAMPLE4
	// dynamic ripples
	half2 cRipples = EXPAND(GetTexture2D(WaterDynRipplesSampler, IN.ripplesTC.xy).xy);
	bumpNormal.xy += cRipples * IN.ripplesTC.w;
#endif

#if %WATER_TESSELLATION_DX11
	bumpNormal.xyz = normalize(IN.vVertexNormal.xyz)*float3(2, 2, 1) + float3(bumpNormal.xy, 0);
#else
	#if !%_RT_QUALITY && %_RT_QUALITY1 	
	//// ref normal
	//float3 faceEdgeA = ddx(  IN.vPosWS );
	//float3 faceEdgeB = ddy(  IN.vPosWS );
	//float3 vtxNormal = -normalize( cross(faceEdgeA, faceEdgeB));
	
	bumpNormal.xyz += IN.vVertexNormal.xyz;
	#endif
#endif

#if %_RT_OCEAN_PARTICLE
	// Fetch rain sample - todo, remove funky 300/tilling after shipping...
	bumpNormal.xy += GetNormalMap(RainRipplesSampler, IN.baseTC.xy * RainTilling * (300.0h / Tilling)).xy * 5.0h; 
#endif

	return normalize( bumpNormal );
}

////////////////////////////////////////////////////////////////////////////////////////////////////

float2 GetParalaxOffset(in v2f_hs IN, half3 vView)
{	
	float4 tcBaseVectorized = IN.baseTC.xyxy * float4(0.25, 0.25, 1, 1) ; //float4(0.05, 0.1, 0.5, 0.25);
	// adds 0.8 ms ....
	//vView.xy /= vView.z;
	
	const half lGradientScale = 0.5 * GradientScale;
	const half lHeightScale   = 0.5 * HeightScale;

	// Compute the height at this location
	half4 height = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBaseVectorized.xy));
	height.xy = lGradientScale * height.xy;
	height.w  = lHeightScale   * height.w;

	// Compute the offset      
	float2 vParalax = vView.xy * height.w + height.xy;

	// Compute the height at this location
	height = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, tcBaseVectorized.zw + vParalax));
	height.xy = lGradientScale * height.xy;
	height.w  = lHeightScale   * height.w;

	// Compute the offset     
	vParalax += vView.xy * height.w+ height.xy;

	// unfortunately just by adding this aditional layer costs 0.6 ms (!) - maybe revive later for hi specs
	//// Compute the height at this location
	//height = ExpandWaterNormals(GetTexture2D(WaterNormalsSampler, IN.baseTC.xy + vParalax));
	//height.xy = lGradientScale * height.xy;
	//height.w  = lHeightScale   * height.w;
	//vParalax += vView.xy * height.w + height.xy;
		
#if %_RT_SAMPLE4
	// Finally add water ripples to paralax offset
	half fSimSize = WATER_RIPPLES_SIM_GRID_SIZE;
	half4 cRipples = EXPAND(GetTexture2D(WaterDynRipplesSampler, IN.ripplesTC.xy + vParalax / fSimSize));

	cRipples.xy = lGradientScale * cRipples.xy;
	cRipples.z  = lHeightScale   * cRipples.z;
	cRipples *= IN.ripplesTC.w;
	
	vParalax += 4 * vView.xy * cRipples.z + cRipples.xy;
#endif

	return vParalax;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void SunSpecular(in v2f_hs IN, half fNdotL, half3 vNormal, half3 vView, inout half3 cSpecularAcc)
{
	half3 R = reflect(-vView, vNormal);
  half LdotR = saturate(dot(g_PS_SunLightDir, R) );

  // 2 spec lobes for ocean	
	half fSpec = dot(IN.GlossinessK.zw, half2( pow(LdotR , IN.GlossinessK.x), pow(LdotR , IN.GlossinessK.y))  );
	
  //half3 cLight = g_PS_SunColor.xyz;;
	half3 cSunSpecular = fNdotL * fSpec * IN.cSpecular; //IN.cSpecular = cLight * MatSpecColor * g_PS_SunColor.xyz * g_VS_SunLightDir.w;
  //cSunSpecular *= PS_HDR_RANGE_ADAPT_MAX;

  // Fake sun shadows: if sun oposing reflected surface normal, its darker - use this as hint for shadows (doens't work 100% but it's better than nothing)
  //	- note: this assumption works only for realtime shadows
  // cSunSpecular *= saturate(dot(cSpecularAcc.xyz, 0.333)*dot(cSpecularAcc.xyz, 0.333)); // squashes sun specular result with low SunColor value

	// Add sun specular term
	cSpecularAcc.xyz += cSunSpecular.xyz;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

pixout WaterPS(v2f_hs IN)
{
	pixout OUT = (pixout) 0;
	
#if %_RT_DEBUG0 || %_RT_DEBUG1 || %_RT_DEBUG2 || %_RT_DEBUG3
 DebugOutput(OUT.Color, IN.baseTC);
 return OUT;
#endif

	half3 vView = normalize(IN.vView.xyz);  			

	// Generate normal map from 4 normal map layers + paralax
	float2 vParalaxOffset = GetParalaxOffset( IN, vView );  
  half3 vNormal = BumpGen( IN, vParalaxOffset);

  // Get ( fNdotE )*sign(vView.z) - we want internal reflections as well - 
  half fNdotE =  (dot( vView.xyz, vNormal ) ) * IN.vView.w;

	////////////////////////////////////////////////////////////////////////////////////////////////// 	
  // Water edge and foam softness  

 	float sceneDepth = DecodeSceneDepth( sceneDepthSampler, IN.screenProj );
 	half softIntersect = saturate( SoftIntersectionFactor * (sceneDepth - IN.screenProj.w) );	

  //////////////////////////////////////////////////////////////////////////////////////////////////    
  // Get reflection color
	
	half fGloss = MatSpecColor.w;
	// Quick solution: Reduce gloss in distance (the better solution is computing a Toksvig factor for the wave normal map)
	fGloss *= clamp( 1 - length( IN.vView.xyz ) / 250, 0.5, 1 );

#if %ENVIRONMENT_MAP
  half3 lerpedNormal = lerp(half3(0,0,1), vNormal, ReflectionBumpScale);
  half3 R = reflect(-vView, lerpedNormal);
  half4 cReflCM = GetEnvironmentCMap(envMapSamplerCUBE, R, fGloss);
  half3 cSpecularAcc = DecodeHDRCubemap(cReflCM) * ReflectionScale;  

#else

  half2 reflNewst = (IN.envTC.xy/IN.envTC.w) + vNormal.xy * ReflectionBumpScale;  
  half3 cSpecularAcc = tex2D(ReflectionSampler, reflNewst) /PS_HDR_RANGE_ADAPT_MAX;	

#endif


  //////////////////////////////////////////////////////////////////////////////////////////////////
  // Get refraction and apply refraction masking

	float fFogDepth = sceneDepth;
  float2 refrNewst = ( IN.screenProj.xy / IN.screenProj.w );                    

	float fSoftCamIsec =1;//saturate( ( IN.screenProj.w- PS_NearFarClipDist.x) * 50);

//if !%NO_REFRACTION_BUMP
	float2 refrTC = vNormal.xy * RefractionBumpScale * softIntersect * IN.screenProj.z; 	  
			
	#if %WATER_TESSELLATION_DX11	
	
		float3 depthRefr = float3(
			GetLinearDepthScaled( sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy*1.025)),
			GetLinearDepthScaled( sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy)),
			GetLinearDepthScaled( sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy*0.985))
		);
	#else

		float3 depthRefr = float3( GetLinearDepthScaled( sceneDepthSampler, ClampScreenTC(refrNewst + refrTC.xy)).xxx);

	#endif

	//if( GetShaderQuality() > QUALITY_LOW )
	//	refrTC  *= fSoftCamIsec;    

	// Apply refraction mask to bump offsets
	half3 fRefractionMask =  (IN.screenProj.www <depthRefr.xyz );	
//	refrNewst += refrTC * fRefractionMask;

//endif

	
	#if %WATER_TESSELLATION_DX11	
		half3 refractColor = DecodeHDRBuffer( tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.x *1.025)) ).xyz;
		refractColor.y = DecodeHDRBuffer( tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.y) ) ).y;
		refractColor.z = DecodeHDRBuffer( tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.z *0.985)) ).z;	
	#else
		half3 refractColor = DecodeHDRBuffer( tex2D(RefractionSampler, ClampScreenTC(refrNewst + refrTC * fRefractionMask.x)) ).xyz;
	#endif
	refractColor /= PS_HDR_RANGE_ADAPT_MAX;

#if %_RT_FOG && %_RT_VOLUMETRIC_FOG
	half3 fogColor = 0;
	float len = length(IN.vView.xyz);
	VolumetricFogTexcoord vtc = GetVolumetricFogTexcoordParamByScreenProj(IN.screenProj, false, len);
	float4 vf = GetVolumetricFogValueJittered(vtc).xyzw;
	half4 globalFogColor = GetVolumetricFogAnalyticalColor(-IN.vView.xyz, len);
	ApplyVolumetricFog(vf, globalFogColor, vtc, fogColor.xyz);

	// subtract fog color from refract color.
	refractColor -= fogColor;
#endif

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Compute ocean fog

	float volumeDepth = max( fFogDepth  - dot( IN.vView.xyz, CameraFrontVector.xyz ), 0 );  
	half waterVolumeFog = exp2( -cFogColorDensity.w * volumeDepth / dot( vView.xyz, CameraFrontVector.xyz ) );  
	refractColor =lerp(cFogColorDensity.xyz, refractColor, saturate(waterVolumeFog) );  

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Get sun specular

	half fNdotL = (dot(vNormal.xyz, g_PS_SunLightDir.xyz) );
#if %SUN_SHINE  
	SunSpecular(IN, saturate(fNdotL), vNormal, vView, cSpecularAcc);
#endif

	// important step - use gloss map to break reflection repetitive look
	half4 cGlossMap = GetTexture2D(WaterGlossMapSampler, IN.baseTC.xy*0.05);//+ vParalaxOffset*0.02);
	cGlossMap  = cGlossMap*0.7+0.3;

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Final compose refraction/reflection/specular based on fresnel - add foam and blend fog 

	const half WaterSpec0 = 0.02;
	half fFresnel = GetEnvmapFresnel( WaterSpec0, FresnelGloss, saturate(fNdotE) ).x;

	// Set world soft intersection * camera soft intersection (looks nice but disabled, since costs 0.2 ms)
	half fCameraSoftIsec = saturate((IN.screenProj.w- 0.33) );
	half fA = softIntersect;
	 fA *= fCameraSoftIsec;    

	half fSunShadow = 1;

	// Fake sun shadows: if sun oposing reflected surface normal, its darker - use this as hint for shadows (doens't work 100% but it's better than nothing)
	//	- note: this assumption works only for realtime shadows
	fSunShadow *= saturate(0.5 + dot(cSpecularAcc.xyz, 0.333)*dot(cSpecularAcc.xyz, 0.333));	

#if %WATER_TESSELLATION_DX11
	// Simple subsurface scattering approximation
	const half3 surfaceSSSColor = MatDifColor.xyz * SubSurfaceScatteringScale;
	
	half EdotL = saturate( dot( -g_PS_SunLightDir.xyz, vView ) );
	float waveHeightFactor = IN.vPosWS.w * 0.5 + saturate(fNdotE) * (1 - saturate( vNormal.z ));
#if %ENVIRONMENT_MAP	
	refractColor += surfaceSSSColor * GetEnvironmentCMap( envMapSamplerCUBE, -vView.xyz, clamp( waveHeightFactor, 0.2, 0.7 ) ) * waveHeightFactor * fA;
#endif
	refractColor += surfaceSSSColor * (EdotL * EdotL) * (cFogColorDensity * g_PS_SunColor) * waveHeightFactor * fA;
#endif

	half3 cFinal = lerp(refractColor, cSpecularAcc, fFresnel * fA);

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Attempt to make something look like foam..

#if %FOAM 

	half4 cFoamThreshold = cGlossMap*2-1;  // reuse gloss for masking edges

	#if %WATER_TESSELLATION_DX11
		//dx11 specific - approximate foam coesion and sparking through mipmap bias
		half fFoam = tex2Dbias(FoamSampler, float4(IN.baseTC.xy*FoamTilling+ vNormal.xy *0.1, 0, -(1-4*IN.vPosWS.w))).x;
	#else
		half fFoam = tex2D(FoamSampler, IN.baseTC.xy*FoamTilling+ vNormal.xy *0.1).x;
	#endif

	half fFoamOrig = fFoam;

	half fFoamSoftIntersect = saturate( max(0.35, FoamSoftIntersectionFactor) * (sceneDepth - IN.screenProj.w ) ); 	// -0.25 => to avoid foam on first person arms, looks ugly
			
	// Blend out edges in interesting way
	fFoam = fFoam * saturate( -fFoamSoftIntersect*(1+cFoamThreshold.x)+fFoam );	
	fFoam = fFoam * saturate(fFoamSoftIntersect -  fFoamSoftIntersect* fFoamSoftIntersect );

	#if %WATER_TESSELLATION_DX11
		//dx11 specific
		fFoam += (saturate(fFoamOrig*IN.vPosWS.w*fFoamOrig*IN.vPosWS.w)*0.5 + smoothstep(0.2, 1, saturate(fFoamOrig*IN.vPosWS.w))*2) * FoamCrestAmount;	
	#endif

	fFoam *= (g_PS_SunColor.xyz * saturate(fNdotL) *fSunShadow) * saturate(FoamAmount);
	fFoam *= fCameraSoftIsec;

	cFinal += fFoam;

#endif

#if %_RT_FOG
#if !%_RT_VOLUMETRIC_FOG
  half4 localFogColor = GetVolumetricFogColor( IN.vPosWS.xyz );
  cFinal.xyz = lerp( localFogColor.xyz , cFinal, localFogColor.w );;
#else
	ApplyVolumetricFog(vf, globalFogColor, vtc, cFinal.xyz);
#endif
#endif

#if %_RT_SAMPLE0
	// debugging ripples activation
  //cFinal.xyz *= 0.01;//+= half3(IN.ripplesTC.w, 0, 0);
	//cFinal.xyz = GetTexture2D(WaterDynRipplesSampler, IN.ripplesTC.xy);
#endif

	OUT.Color.xyz =  cFinal * PS_HDR_RANGE_ADAPT_MAX;
  
  return OUT;
}

//////////////////////////////// technique ////////////////

technique Water
{
	pass p0
	{
		ZEnable = true;
		ZFunc = LEqual;
		CullMode = None; 
		ZWriteEnable = false;

		IgnoreMaterialState = true;

		VertexShader = WaterVS() WaterSurfaceVS;

#if %WATER_TESSELLATION_DX11
		HullShader   = WaterHS() WaterSurfaceHS;
		DomainShader = WaterDS() WaterSurfaceDS;
		//GeometryShader = WaterGS();
#endif
		PixelShader = WaterPS() WaterSurfacePS;
	}
}

/////////////////////// eof ///
